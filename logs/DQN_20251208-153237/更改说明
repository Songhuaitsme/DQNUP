参数

# --- 拓扑配置 ---
NODE_NUM = 12  # 0号为调度器，1-11为数据中心
DEFAULT_LINK_BANDWIDTH = 100  # 默认链路总带宽 (Mbps)
DEFAULT_NODE_CPU = 80        # 默认节点总CPU资源 (单位)

# --- 动态定价参数 (参考 Xiao et al. 文献) ---
PRICE_ALPHA = 2.0  # 价格增长系数
PRICE_BETA = 3.0   # 指数因子 (非线性程度)

# --- 任务配置 ---
TASK_GENERATION_PROB = 0.8  # 每个时间步生成新任务的概率
TASK_DURATION_MEAN = 20    # 任务平均持续时间 (时间步)
TASK_CPU_DEMAND = (5, 20)   # 任务CPU需求范围 (min, max)
TASK_BW_DEMAND = (10, 50)   # 任务带宽需求范围 (min, max)

# --- DQN 训练配置 ---
LEARNING_RATE = 0.001
GAMMA = 0.95
EPSILON_START = 1.0
EPSILON_MIN = 0.01
EPSILON_DECAY = 0.999
BATCH_SIZE = 64
MEMORY_CAPACITY = 10000
MAX_STEPS = 20000  # 总模拟步数


价格更改

    def load_base_prices() -> Dict[int, Dict[str, float]]:
        """
        加载表3中的资源基础价格
        返回结构: {node_id: {'cpu': 0.1164, 'bw': 0.334}}
        """
        # 0号调度器价格为0
        prices = {0: {'cpu': 0.0, 'bw': 0.0}}

        # 表3 数据 (数据中心 1-11)
        # 格式: ID: (CPU价格, 带宽价格)
        table_data = {
            1: (0.1164, 0.334),
            2: (0.1122, 0.456),
            3: (0.1063, 0.385),
            4: (0.1102, 0.489),
            5: (0.1190, 0.399),
            6: (0.1010, 0.367),
            7: (0.1250, 0.347),
            8: (0.1050, 0.397),
            9: (0.1110, 0.343),
            10: (0.1220, 0.385),
            11: (0.1170, 0.356)
        }

        for node_id, (cpu_p, bw_p) in table_data.items():
            prices[node_id] = {
                'cpu': cpu_p,
                'bw': bw_p
            }

        return prices

带宽
节点偏好变了:

    以前 Agent 喜欢节点2是因为它距离近（距离100）。

    现在 Agent 可能会喜欢节点6或节点8，因为它们的基础单价更低。

        节点6 CPU: 0.1010 (最低)

        节点9 BW: 0.343 (很低)

    距离 (dist) 在新的成本公式中被移除了（因为表格没有提供基于距离的运费），现在的通信成本纯粹由“目标节点的带宽收费标准”决定。这符合很多云服务的“流量出口费”模式。

公式调整:

    我将 compute_cost 改为了 单价 * 核数 * 时长（之前代码里好像没乘核数 task['cpu']，如果表单价是“每核”，则必须乘）。

    如果你希望 compute_cost 仅仅是 单价 * 时长（假设任务都是标准大小），可以把 * task['cpu'] 去掉。但我建议乘上，因为任务有大有小（5-20核）。

建议重新训练:

    因为奖励函数（Reward Function）背后的物理意义完全变了，旧模型的经验（“选距离近的”）现在可能完全失效（“选便宜的”）。请务必重新运行 train.py。



结果分析：
原因一：物理带宽不足 (最主要原因)
    问题分析：

    在 config.py 中，你的链路带宽 DEFAULT_LINK_BANDWIDTH = 100。

    你的任务带宽需求 TASK_BW_DEMAND = (10, 50)，平均约 30 Mbps。

    你的任务生成概率 TASK_GENERATION_PROB = 0.8（非常高！）。

    后果：一条链路平均只能跑 3个任务。当任务像潮水一样涌来（0.8的概率），整个网络的链路瞬间就被堵死了。此时，无论 Agent 选哪个节点，find_constrained_path 都会返回 None，导致任务失败。这不是 Agent 笨，是路真的堵死了。

原因二：失败惩罚太轻 (Reward Shaping)
    问题分析：

    成功的奖励：1000 - Cost。

    新的计费公式下，Cost 可能很高。假设选了一个贵的节点，Cost 可能是 400。

    那么成功的奖励 = 1000 - 400 = 600。

    失败的惩罚：你在 network_env.py 里设置的是 -500。

    后果：Agent 可能会觉得：“我费劲找个节点还要花钱，最后拿 600 分；我直接摆烂失败扣 500 分。好像摆烂的代价也没那么大？”

    逻辑：在资源调度中，可用性 (Availability) 永远大于 成本 (Cost)。拒绝服务的惩罚必须远大于花钱服务的代价。

    ✅ 修改建议 2：加大惩罚（修改 network_env.py） 将失败惩罚提高到 -2000 甚至更低，告诉 Agent：“只要能成功，贵点也没关系，千万别失败！”

原因三：State 信息缺失 (Agent 是瞎子)
    问题分析：

    现在的失败大多是因为 带宽不足 (Path Unavailable)。

    但是你的 get_global_state 函数只返回了 CPU 占用率 (usage_vec)。

    后果：Agent 看不到哪里堵车了！它只知道节点 CPU 是空的，却不知道去那个节点的路上已经堵死了。它只能在那边“瞎猜”，导致成功率上不去。

    ✅ 修改建议 3：增加带宽感知 (修改 network_env.py) 虽然完全把整个图的链路状态放进 State 很难（维度太高），但我们可以加一个简单的特征：“全网平均链路负载” 或者 “与目标节点相连的链路负载”。

    考虑到修改复杂性，暂时先不做代码大改。只要执行了建议1和建议2，成功率应该就能回到 90% 以上。